// // This is the service definition. It looks a lot like a trait definition.
// // It defines one RPC, hello, which takes one arg, name, and returns a String.
// #[tarpc::service]
// pub trait World {
//     /// Returns a greeting for name.
//     async fn hello(name: String) -> String;
// }

// pub mod client;
// pub mod server;
// use client::client_rpc::{World, WorldClient};
// use futures::prelude::*;
// use server::server_rpc::HelloServer;
// use tarpc::{
//     client as tarpc_client, context,
//     server::{self as tarpc_server, Channel},
// };
// #[tokio::main]
// async fn main() -> anyhow::Result<()> {
//     let (client_transport, server_transport) = tarpc::transport::channel::unbounded();
//     HelloServer.serve();
//     let server_tarpc = tarpc_server::BaseChannel::with_defaults(server_transport);
//     tokio::spawn(
//         server_tarpc
//             .execute(HelloServer.serve())
//             // Handle all requests concurrently.
//             .for_each(|response| async move {
//                 tokio::spawn(response);
//             }),
//     );

//     // WorldClient is generated by the #[tarpc::service] attribute. It has a constructor `new`
//     // that takes a config and any Transport as input.
//     let client_tarpc = WorldClient::new(tarpc_client::Config::default(), client_transport).spawn();

//     // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
//     // args as defined, with the addition of a Context, which is always the first arg. The Context
//     // specifies a deadline and trace information which can be helpful in debugging requests.
//     let hello = client_tarpc
//         .hello(context::current(), "Stim".to_string())
//         .await?;

//     println!("{hello}");

//     Ok(())
// }
